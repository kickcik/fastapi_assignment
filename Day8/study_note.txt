1. index

- 한 번 쿼리되면 메모리상에 머물며, 같은 요청을 더욱 빠르게 응답할 수 있게 해주어, 더 빠른 응답을 보여준다.
- 인덱스는 정렬된 tree이기에 데이터를 찾는 속도가 빠르다.

[Scan의 종류] (성능순)
1. Index Range Scan: 인덱스의 일부 범위만 읽어서 쿼리를 처리한다.
    -> 부분을 읽기 때문에 당연히 가장 빠르다.
2. Index Full Scan: 인덱스를 모두 읽어서 쿼리를 처리한다.
    -> 해당 인덱스의 전체를 훑는다.
3. Table Full Scan: 테이블 전체를 읽어서 쿼리를 처리 (테이블 크기가 클 경우 전면장애까지 이어질 수 있는 위험한 쿼리라고합니다.)
    -> 하지만 병렬 스캔을 통해 자원을 투입하면 해결 가능하기도 하다.

[covered query]
- index만 사용해서 처리할 수 있는 쿼리
- 디스크 조회 연산이 일어나지 않기 때문에 성능이 좋다.

[B tree]
- 균형잡힌 트리로, 리프 노드까지 거리가 일정하다.
- 삽입, 삭제시에 노드를 조정해서 리프까지의 거리가 일정하도록 조정한다.
- 각 노드는 key, pointer를 갖고, key는 정렬돼있고, pointer는 key를 기준으로 미만, 사이, 초과에 대한 다음 노드를 가리킨다.
- 리프 노드에는 실제 데이터의 주소가 있다.

- 삽입 / 삭제 동작
    - 삽입 :
        1. 루트 노드에서 시작해서 타고 내려간다.
        2. 리프 노드의 공간이 비었다면 삽입 후 정렬한다.
        3. 공간이 없다면, key개수의 중간값을 기준으로 나눠진 key들을 각각 갖는 두 개의 노드로 분할한다.
        4. 부모 노드에 리프 노드를 구분하는 경곗값(boundary key)을 가지는 key를 올려보낸다.
        5. 만약, 부모 노드도 꽉 찼다면, 부모 노드도 같은 방식으로 분할한다.
        6. 만약, 루트까지 분할이 전파됐다면, 새로운 루트 노드가 맨 위에 생기고, 높이가 1 증가한다.

    - 삭제 :
        1. 루트 노드에서 시작해서 타고 내려간다.

        <내부 노드의 key를 삭제하는 경우>
        2. 전임자, 후임자 중 하나를 택한다.
        (전임자: 삭제할 key의 왼쪽 서브 트리 중 가장 큰 값, 후임자: 삭제할 key의 오른쪽 서브 트리 중 가장 작은 값)
        (하나의 구현체에서 전임자, 후임자 중 하나를 택하나, 일관적으로 선택해야 한다.)
        3. 삭제할 원래 key를 전임자나 후임자 key로 바꾼다.
        4. 서브 트리에서 전임자나 후임자의 key를 삭제한다.

        <리프 노드의 key를 삭제하는 경우>
        2. 해당 key를 삭제한다.
        3. underflow를 확인한다. (최소 개수 미달)
            <underflow의 경우>
            4. 형제 노드에 여분의 key가 있다면, key를 하나 빌려온다. (Rotation 또는 Borrowing)
            5. 만약, 형제 노드에도 여분이 없다면, 부모의 key를 내려주고, underflow가 난 노드와 형제 노드를 합친다.
            6. 만약, 부모 노드도 underflow가 난다면, 4, 5를 반복한다.
            7. 만약, 루트 노드까지 전파되고, 루트 노드마저 underflow가 발생하면,
                해당 루트는 삭제되고, 자식이 새로운 루트 노드가 되며, 트리 높이가 1 감소한다.

[B + Tree]
- 리프 노드끼리 링크드 리스트로 연결되어 있다.

2. Semantic Version 과 poetry lock 파일
- poetry는 lock 파일이 있는지 확인한 뒤, 있으면 lock 파일에 적혀있는 버전을 정확하게 설치한다.

[하위호환성]
- 클라이언트 쪽에서 변경이 있어야만 새로운 버전의 기능을 사용할 수 있을때 하위 호환성이 깨진다.

- pyproject.toml 의 `^` 은 “하위 호환성을 깨지 않는 범위에서 가장 최신 버전을 사용하라” 라는 의미이다.
- 실제 설치해야 하는 정확한 버전은 `poetry.lock` 파일에 기록되어 있다.
- version 문자열 `x.y.z` 는 임의의 숫자가 아니라 규칙이며, 이 규칙을 SemVer 라고 부른다.
- SemVer 에 의하면
    - x: major, 하위 호환성을 깨뜨리는 변경을 했다면 major가 증가해야 한다.
    - y: minor, 하위 호환성을 깨지 않는 기능 추가는 minor가 증가해야 한다.
    - z: patch, 하위 호환성을 깨지 않는 버그 수정은 patch가 증가해야 한다.

3. asyncio
- asyncio를 사용하는 FastAPI가 Django, Flask보다 빠른 이유는 비동기를 지원하기 때문이다.
- 작업을 처리하는 방식에서 이점을 얻는 것이지, 연산 자체가 더 빠른 것이 아니다.

[File Descriptor]
- 열려 있는 파일을 식별하는 정수 ”integer”이다.
    ->

- 리눅스에서
    1. 프로세스가 파일을 열겠다는 요청을 운영체제에게 합니다. 이것이 시스템 콜 open()이다.
    2. 파일이 현재 “열 수 있는 상태” 라면 운영체제가 파일을 열어준다. 이후 시스템 콜 open()이 정수를 반환하는데,
       이 정수가 file descriptor이다.
    3. 이후 파일을 읽거나 쓸 때 이 파일 디스크립터를 가지고 운영체제와 소통한다.
        -> 예를 들어 2번에서 얻은 파일 디스크립터가 정수 4 였다면 `write(4 "abc")` 는 “4번 파일에 “abc” 라고 써 줘” 라는 요청이 된다.
        -> 만약 타임아웃이 지나도록 어떠한 소켓들도 응답이 돌아오지 않는다면 -1 을 반환한다.

- python 에서 await 키워드를 사용할 수 있는 대상을 awaitable 이라고 부르며, awaitable에는 coroutine, task, future등이 있다.

[Await 이해하기]
    [future]
        - 이벤트 루프의 핵심 요소.
        - io 가 완료될때 까지 기다리는 기능
        - 기다리는 중에 취소하는 기능
        - 기다림이 완료 된 후 스스로를 “완료” 처리 하는 기능
        - io 완료 이후에 결과값을 리턴하는 기능

    [task]
        - Future를 상속받은 클래스, future의 모든 기능을 다 가지고 있다.
        - 멈춰졌다가 실행되는 기능만 있는 coroutine에게 future의 기능을 부여 하는 역할을 한다.
        - coroutine을 task 로 감싼 이후에야 비로소 coroutine이 이벤트 루프에서 실행될 수 있다.

    [coroutine]
        - async def 비동기 함수가 리턴하는 객체로, 함수를 실행 중에 멈추었다가 다시 재개하는 기능을 갖고 있다.
        - 또한 Task 에 의해 감싸지면 이벤트 루프로 실행될 수 있다.

    [await]
        - 실행흐름을 이벤트 루프에게 양도한다.
        - await이 coroutine 을 만난 경우 코루틴을 바로 실행한다. (이때 대기하지 않고, 이벤트 루프로 실행흐름이 이동하지도 않는다.)
        - await이 future 혹은 task 를 만난 경우 이 future 혹은 task 가 완료될때 까지 대기한다.
        - 대기하면서 실행 흐름은 이벤트 루프에게로 넘어가고, 이벤트루프는 다른 future 혹은 task 를 실행할 수 있다.

    - async 키워드가 붙은 함수를 호출하면 함수가 실행되는 대신 코루틴 객체가 리턴된다.
    - async 키워드가 붙은 함수 안에서는 await 을 사용할 수 있다.

    [asyncio.gather()]
        - 실행시 인자로 받은 coroutine을 task로 감싼다.
        - 변환과 동시에 이벤트 루프에 자동으로 등록된다.
        - 등록만 될 뿐이지, 실제 실행을 위해서는 await을 만나 실행 흐름이 이벤트 루프에게 넘어가야 한다.

    [event_loop]
        - deque인 _ready, heap인 _scheduled를 가지고 있다.
        - 바로 실행가능한 coroutine은 _ready에 있다 바로 실행된다.
        - 그렇지 않은 coroutine은 _scheduled에서 대기하고 있다가 실행가능할 때 _ready로 이동 후 실행된다.
        - deque _ready 안에는 당장 실행 가능한 task 혹은 future들이 들어있다.
        - 이벤트 루프는 _ready 안의 task를 순차적으로 꺼내 실행한다.

[Asyncio의 병렬처리]
    [gather()]
        - await asyncio.gather()에 의해 차례대로 coroutine이 task에 감싸져 이벤트 루프에 등록된다.
        - 대기시간이 빠른 순서대로 코루틴들이 종료된다.
        - 모든 코루틴이 종료된 후 await asyncio.gather()가 종료된다.

    [as_completed()]
        - as_completed()는 내부적으로 set()을 사용하기 때문에 coroutine 실행순서가 보장되지 않는다.
        - as_completed()에 의해 task, future가 루프에 등록되지만, await를 만나지 않는다면,
          아직 이벤트 루프로 실행 흐름이 넘어가지 않았기에 실행은 되지 않는다.
        - await를 만났을때 실행 흐름이 이벤트 루프로 넘어가고, 등록된 coroutine이 모두 실행되며,
          가장 먼저 종료되는 coroutine이 끝날 때까지 block 된다.
